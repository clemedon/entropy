#!/usr/bin/env python3
import sounddevice

# TODO  NIST Statistical Test Suite or Diehard tests.

import hashlib
import pyaudio
import numpy as np


def record_audio(duration, rate=44100, chunk_size=1024):
    audio = pyaudio.PyAudio()
    stream = audio.open(
        format=pyaudio.paInt16,
        channels=1,
        rate=rate,
        input=True,
        frames_per_buffer=chunk_size,
    )

    # print("Recording audio...")
    frames = []
    for _ in range(0, int(rate / chunk_size * duration)):
        data = stream.read(chunk_size)
        frames.append(data)

    # print("Finished recording.")

    stream.stop_stream()
    stream.close()
    audio.terminate()

    return frames


def generate_random_numbers(audio_data, num_numbers=5, range_start=1, range_end=6):
    # Convert frames to a single numpy array
    audio_data = np.frombuffer(b"".join(audio_data), dtype=np.int16)

    # Calculate the number of chunks needed to generate num_numbers
    chunk_size = len(audio_data) // num_numbers

    random_numbers = []
    for i in range(num_numbers):
        # Extract a chunk of audio data
        chunk = audio_data[i * chunk_size : (i + 1) * chunk_size]

        # Calculate the hash of the chunk
        chunk_hash = hashlib.sha256(chunk).digest()

        # Convert the hash to an integer and map it to the desired range
        hash_int = int.from_bytes(chunk_hash, byteorder="big", signed=False)
        mapped_number = range_start + (hash_int % (range_end - range_start + 1))

        # Ensure that the number is in the range [1, 6]
        if mapped_number > 6:
            mapped_number -= 6

        random_numbers.append(mapped_number)

    return random_numbers



def main():
    duration = 1  # seconds
    for i in range(0, 100):
        frames = record_audio(duration)
        random_numbers = generate_random_numbers(frames)
        for i, number in enumerate(random_numbers):
            print(f"{number}", end="")
        print()


if __name__ == "__main__":
    main()
